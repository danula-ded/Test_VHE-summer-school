B. Обратная польская нотация
============================
<table>
         <tr >
            <td >Ограничение времени</td>
            <td>5&nbsp;секунд</td>
         </tr>
         <tr >
            <td >Ограничение памяти</td>
            <td>64Mb</td>
         </tr>
         <tr >
            <td >Ввод</td>
            <td >стандартный ввод или input.txt</td>
         </tr>
         <tr >
            <td >Вывод</td>
            <td >стандартный вывод или output.txt</td>
         </tr>
      </table>

Обратной польской нотацией называется принцип записи арифметического выражения, указывающий на порядок выполнения арифметических операций.  
По правилам обратной польской нотации сначала записываются два числа, над которыми будет выполнена операция, а затем сама операция.  
Пример: 1 2 + 3 4 + \*  
Сначала выполняется сложение чисел 1 и 2, затем сложение чисел 3 и 4, а потом берется произведение полученных результатов, то есть данное выражение можно записать как (1 + 2) \* (3 + 4).  

Формат ввода
------------

Строка с выражением в обратной польской нотации (все числа целые положительные).

Формат вывода
-------------

Результат выражения.

### Пример 1

Ввод
```
1 2 + 3 4 + \*
```
Вывод
```
21
```

### Пример 2

Ввод

```
1 3 \* 20 4 / 7 3 - \* +
```

Вывод

```
23
```

Примечания
----------

В данной задаче выражение может содержать в себе только четыре операции: +, -, \* и /.

C. Двоичный код!
================

<table >
            <tbody>
                <tr >
                    <td >Ограничение времени</td>
                    <td>4.999&nbsp;секунд</td>
                </tr>
                <tr >
                    <td >Ограничение памяти</td>
                    <td>64.0 Мб</td>
                </tr>
                <tr >
                    <td >Ввод</td>
                    <td >стандартный ввод</td>
                </tr>
                <tr >
                    <td >Вывод</td>
                    <td >стандартный вывод</td>
                </tr>
            </tbody>
        </table>

Петя и Вася попали на урок информатики, на котором им рассказывали про перевод чисел в двоичную систему счисления из десятеричной системы счисления. В последней задаче в их задании Петю с Васей просят перевести в двоичный код не одно число, а аж произведение двух! Как вы могли понять из предыдущих задач, Петя с Васей - ребята ленивые, а потому хотели бы автоматизировать и этот процесс. Помогите им!)

Формат ввода
------------

Программа получает из консоли два числа ( a a a, b b b), разделённых пробелом. Гарантируется, что каждое из введённых чисел является корректно записанным целым, и неотрицательным. Вводимые числа лежат в следующих диапазонах: 0 ≤ a < 2 64 0 \\leq a \\lt 2^{64} 0≤a<264; 0 ≤ b < 2 64 0 \\leq b \\lt 2^{64} 0≤b<264, и лежат в десятичной системе счисления.

Формат вывода
-------------

Вам необходимо перевести в двоичный вид произведение этих двух чисел, и вывести в консоль строку, являющуюся результатом этого перевода.

### Пример 1

Ввод

```
3 4
```

Вывод
```
1100
```

### Пример 2

Ввод

```
21 6
```

Вывод
```
1111110
```

Примечания
----------

ВАЖНО: составители не ошиблись, указав такие диапазоны допустимых значений. Кроме того, вы не обязаны получить полный балл (рассматривайте эту задачу, как исследовательскую, и смотрите внимательно на систему оценки).

**При решении этой задачи НЕЛЬЗЯ пользоваться никакими встроенными методами перевода чисел в двоичный вид!!! (например запрещены аналоги std::bitset из С++)** За нарушение этого правила результат по задаче будет обнулён при ручной проверке.

D. Найди подстроку!
===================
<table >
            <tbody>
                <tr >
                    <td >Ограничение времени</td>
                    <td>4.5&nbsp;секунд</td>
                </tr>
                <tr >
                    <td >Ограничение памяти</td>
                    <td>245.2 Мб</td>
                </tr>
                <tr >
                    <td >Ввод</td>
                    <td >стандартный ввод</td>
                </tr>
                <tr >
                    <td >Вывод</td>
                    <td >стандартный вывод</td>
                </tr>
            </tbody>
        </table>

Всё просто - выведите все вхождения подстроки в строке. Но чем оптимальнее вы будете это делать - тем лучше (и тем больше баллов вы заработаете)))).  

Формат ввода
------------

На вход из консоли подаётся две строки s 1 s1 s1 и s 2 s2 s2, длиной n 1 n1 n1 и n 2 n2 n2 соответственно.  

Первая строка – s 1 s1 s1 ( 0 ≤ n 1 ≤ 1 0 3 ) (0 \\leq n1 \\leq 10^3) (0≤n1≤103) – строка, вхождения которой ищем.  

Вторая строка – s 2 s2 s2 ( 0 ≤ n 2 ≤ 1 0 7 ) (0 \\leq n2 \\leq 10^7) (0≤n2≤107) – текст, в котором ищутся вхождения строки.  

Гарантируется, что строки состоят только из букв латинского алфавита, и разделены '\\n'. ВТОРАЯ СТРОКА НА '\\n' НЕ ЗАКАНЧИВАЕТСЯ!. (считывайте через getline / cin.get() (с++) / аналоги в других языках.)  

Формат вывода
-------------

На первой строке выведите в консоль количество вхождений строки в текст.  

Гарантируется, что количество вхождений строки в текст не превышает 1 0 6 10^6 106.  

На каждой следующей строке выведите в консоль номера позиций (индексирование ведётся с 0), с которых начинаются очередные вхождения строки. За последним номером также следует перенос строки.  

### Пример 1

Ввод

```
bc
dcbbabcaababcccbcbba
```

Вывод
```
3
5
11
15
```

### Пример 2

Ввод

```
dad
dcbdbdcabbcdcddcacaa
```

Вывод
```
0
```

### Пример 3

Ввод
```
cbacbcbbdb
cdca
```
Вывод
```
0
```

Примечания
----------

Эта задача - "исследовательская". Не страшно, если вы получите по ней неполный балл, но старайтесь максимизировать получаемый! (то есть, написать как можно более быстро работающий код)

Кроме того, советую почитать вам на досуге о том, как ускорить (по возможности) считывание из консоли. Например - про функции std::cin.tie(), std::cout.tie(), и std::ios\_base::sync\_with\_stdio() (в с++) / аналоги данных методов на тех языках, на которых вы пишете. Ибо, при работе с большими строками, до 90% всего времени выполнения программы может занимать ввод-вывод данных....)

E. Точки и отрезки
==================
<table >
            <tbody>
                <tr >
                    <td >Ограничение времени</td>
                    <td>5&nbsp;секунд</td>
                </tr>
                <tr >
                    <td >Ограничение памяти</td>
                    <td>80.0 Мб</td>
                </tr>
                <tr >
                    <td >Ввод</td>
                    <td >стандартный ввод</td>
                </tr>
                <tr >
                    <td >Вывод</td>
                    <td >стандартный вывод</td>
                </tr>
            </tbody>
        </table>
Даны два множества: отрезки на прямой и точки.

Для каждой точки из второго множества, определите количество отрезков, которым она принадлежит.

Точка считается принадлежащей отрезку, если она находится внутри него или на границе.

Формат ввода
------------

В первой строке задано два целых числа n n n и m m m ( 1   ≤   n ,   m   ≤   5 ⋅ 1 0 4 ) (1 \\leq n, m \\leq 5 \\cdot 10^4) (1 ≤ n, m ≤ 5⋅104) – количество отрезков и точек на прямой, соответственно.

Следующие n n n строк содержат по два целых числа l i l\_i li​ и r i r\_i ri​ ( l i ≤ r i ) (l\_i \\leq r\_i) (li​≤ri​) – координаты концов отрезков.

Последняя строка содержит m m m целых чисел – координаты точек. Все координаты не превышают 1 0 8 10^8 108 по модулю.

### Пример 1

Ввод

```
2 3
0 5
7 10
1 6 11
```
Вывод
```
1 0 0
```
### Пример 2

Ввод

```
5 5
1 3
2 4
3 10
4 5
1 3
1 2 3 4 5
```
Вывод
```
2 3 4 3 2
```
### Пример 3

Ввод

```
3 3
1 1
2 2
3 3
-1 0 1
```
Вывод
```
0 0 1
```
F. Симметрия
============

<table>
         <tr >
            <td >Ограничение времени</td>
            <td>5&nbsp;секунд</td>
         </tr>
         <tr >
            <td >Ограничение памяти</td>
            <td>64Mb</td>
         </tr>
         <tr >
            <td >Ввод</td>
            <td >стандартный ввод или input.txt</td>
         </tr>
         <tr >
            <td >Вывод</td>
            <td >стандартный вывод или output.txt</td>
         </tr>
      </table>
Петя и Вася играют в игру со следующими правилами: Петя называет четырехзначное число, а Вася должен быстро понять, симметричное оно или нет. Если число симметричное, Вася говорит: "1", иначе любое другое число, которое придет ему в голову. Иногда Петя забывает, что числа должны быть четырехзначными, и называет число, в котором меньше четырех знаков. В таком случае Вася считает, что десятичная запись числа слева дополняется незначащими нулями.

Формат ввода
------------

Вводится не более чем четырехзначное целое число.

Формат вывода
-------------

Программа должна вывести 1, если число симметричное, а иначе любое другое целое число.

### Пример 1

Ввод

```
1441
```

Вывод
```
1
```

### Пример 2

Ввод

```
2020
```

Вывод
```
19
```

Примечания
----------

При решении задачи нельзя использовать циклы и условный оператор if.


G. Интерфейсы
=============

Зачем нужны интерфейсы?

- [ ] Для обеспечения множественного наследования, что позволяет одному классу наследовать несколько других классов одновременно.
- [X] Они позволяют взаимодействовать с объектами классов, вне зависимости от конкретной реализации.
- [ ] Для улучшения модульности и структурирования кода, что позволяет разделить программу на независимые модули с чётко определёнными взаимодействиями.
- [ ] Для обеспечения безопасности данных, так как интерфейсы могут шифровать передаваемую информацию между объектами.


H. Покемон
==========

Выберите список, где среди инструментов облачной и мобильной разработки спрятались только 2 покемона?

- [ ] Viper, Node, Spinda, Next, Proxyman
- [ ] Webkit, Redux, React, Angular, Stantler
- [ ] Seviper, Mongo, Kingfisher, Qwilfish, Jest
- [ ] Struct, Dedenne, Vanilluxe, Basculin, Maractus

I. VS
=====

В чём разница между инкапсуляцией и сокрытием?

- [X] Инкапсуляция – объединение данных и методов в одну сущность. Сокрытие – ограничение доступа для реализации и защиты данных от изменений.
- [ ] Инкапсуляция – объединение данных и методов в одну сущность и обязательное их сокрытие. Сокрытие – просто другой термин для инкапсуляции, без дополнительных отличий.
- [ ] Инкапсуляция – процесс создания интерфейсов для взаимодействия с объектом. Сокрытие – разделение данных и методов на разные уровни доступа, чтобы ограничить видимость и изменение данных.
- [ ] Инкапсуляция – способ разделения программы на модули с ограниченным доступом. Сокрытие – техника, используемая для оптимизации работы программы за счёт скрытия ненужных деталей от пользователя.